#!/usr/bin/env python3
"""Deploy optimized streamdeck script to Pi with Cyberpunk Dashboards"""
import json
import os
import sys

# Constants
PI_HOST = '192.168.1.112'
PI_USER = 'cem'
PI_PASS = '3235'
PI_SCRIPT = '/home/cem/streamdeck_fast.py'
PI_ICONS_DIR = '/home/cem/streamdeck_icons'
LOCAL_ICONS_DIR = 'streamdeck_icons'
CONFIG_FILE = 'streamdeck_config_v3.json'

# Pi-hole settings
PIHOLE_PASSWORD = "3235"
PIHOLE_URL = "http://localhost"

def generate_pi_script(config):
    pages_code = json.dumps(config['pages'], indent=4)
    pages_code = pages_code.replace('null', 'None').replace('true', 'True').replace('false', 'False')
    bg_color = config.get('background_color', [8, 8, 18])
    windows_ip = config.get('windows_ip', '192.168.1.13')

    script = f'''#!/usr/bin/env python3
"""
Unified StreamDeck - Cyberpunk Dashboards + Button Pages
Auto-generated by deploy_to_pi.py
"""
import os, mmap, time, requests, threading, select, subprocess, json
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from evdev import InputDevice, ecodes

# ============== CONFIG ==============
WINDOWS_PC_IP = "{windows_ip}"
WINDOWS_PORT = 5555
FB_DEV = "/dev/fb1"
TOUCH_DEV = "/dev/input/event0"
WIDTH, HEIGHT = 480, 320
ICONS_DIR = "{PI_ICONS_DIR}"

CAL_X_MIN, CAL_X_MAX = 600, 3550
CAL_Y_MIN, CAL_Y_MAX = 750, 3300
INVERT_Y = True

# Pi-hole settings
PIHOLE_PASSWORD = "{PIHOLE_PASSWORD}"
PIHOLE_URL = "{PIHOLE_URL}"

# Colors - Cyberpunk theme
BG_COLOR = (8, 8, 18)
CARD_BG = (15, 15, 25)
CARD_BORDER = (45, 48, 65)
TEXT_PRIMARY = (255, 255, 255)
TEXT_SECONDARY = (140, 145, 165)
TEXT_MUTED = (90, 95, 110)

# Accent colors
CYBER_ORANGE = (255, 160, 0)
CYBER_GOLD = (255, 200, 50)
CYBER_BRIGHT = (255, 230, 120)
CYBER_DIM = (180, 130, 40)
CYBER_CYAN = (0, 220, 255)
CYBER_GREEN = (0, 255, 120)
CYBER_RED = (255, 80, 80)
CYBER_PURPLE = (200, 100, 255)
GREEN = (46, 204, 113)
ORANGE = (255, 170, 50)
PIHOLE_RED = (205, 55, 65)
DOCKER_BLUE = (30, 144, 255)

# Dashboard pages
DASHBOARD_PAGES = ["system", "windows", "pihole", "docker"]
NUM_DASHBOARD_PAGES = len(DASHBOARD_PAGES)

# Button pages
BUTTON_PAGES = {pages_code}

TOTAL_PAGES = NUM_DASHBOARD_PAGES + len(BUTTON_PAGES)

# Layout
COLS, ROWS = 3, 2
MARGIN = 10
NAV_HEIGHT = 38
NAV_Y = HEIGHT - NAV_HEIGHT
BTN_W = (WIDTH - (COLS + 1) * MARGIN) // COLS
BTN_H = (HEIGHT - NAV_HEIGHT - (ROWS + 1) * MARGIN) // ROWS
LEFT_NAV = (0, NAV_Y, 75, HEIGHT)
RIGHT_NAV = (WIDTH - 75, NAV_Y, WIDTH, HEIGHT)

# Framebuffer
fb = os.open(FB_DEV, os.O_RDWR)
fb_mmap = mmap.mmap(fb, WIDTH * HEIGHT * 2)

current_page = 0
gif_frame_indices = {{}}
gif_cache = {{}}

# Pi-hole session
pihole_sid = None
pihole_sid_time = 0

# ============== FONTS ==============
print("Loading fonts...")
try:
    font_title = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 20)
    font_big = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 28)
    font_large = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 24)
    font_medium = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 16)
    font_small = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 13)
    font_tiny = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 11)
    font_btn = font_medium
    font_nav = font_large
except:
    font_title = font_big = font_large = font_medium = font_small = font_tiny = font_btn = font_nav = ImageFont.load_default()

# ============== HELPER FUNCTIONS ==============
def write_to_fb(img):
    arr = np.array(img, dtype=np.uint16)
    rgb565 = ((arr[:,:,0] >> 3) << 11) | ((arr[:,:,1] >> 2) << 5) | (arr[:,:,2] >> 3)
    fb_mmap.seek(0)
    fb_mmap.write(rgb565.astype(np.uint16).tobytes())

def draw_nav_bar(draw, page_num):
    # Cyberpunk style nav bar
    draw.rectangle([0, NAV_Y, WIDTH, HEIGHT], fill=(10, 10, 18))
    draw.line([0, NAV_Y, WIDTH, NAV_Y], fill=CYBER_ORANGE, width=2)
    
    # Left arrow button
    if page_num > 0:
        draw.rectangle([LEFT_NAV[0]+2, NAV_Y+4, LEFT_NAV[2]-2, HEIGHT-4], outline=CYBER_ORANGE, width=2)
        draw.text((30, NAV_Y + 8), "<", fill=CYBER_BRIGHT, font=font_medium)
    else:
        draw.rectangle([LEFT_NAV[0]+2, NAV_Y+4, LEFT_NAV[2]-2, HEIGHT-4], outline=(80, 60, 20), width=1)
        draw.text((30, NAV_Y + 8), "<", fill=(80, 60, 20), font=font_medium)
    
    # Right arrow button
    if page_num < TOTAL_PAGES - 1:
        draw.rectangle([RIGHT_NAV[0]+2, NAV_Y+4, RIGHT_NAV[2]-2, HEIGHT-4], outline=CYBER_ORANGE, width=2)
        draw.text((WIDTH - 45, NAV_Y + 8), ">", fill=CYBER_BRIGHT, font=font_medium)
    else:
        draw.rectangle([RIGHT_NAV[0]+2, NAV_Y+4, RIGHT_NAV[2]-2, HEIGHT-4], outline=(80, 60, 20), width=1)
        draw.text((WIDTH - 45, NAV_Y + 8), ">", fill=(80, 60, 20), font=font_medium)
    
    # Center page selector with dots
    center_x = WIDTH // 2
    dot_spacing = 18
    total_dots_width = (TOTAL_PAGES - 1) * dot_spacing
    btn_w = total_dots_width + 40
    
    draw.rectangle([center_x - btn_w//2, NAV_Y+4, center_x + btn_w//2, HEIGHT-4], outline=CYBER_ORANGE, width=2)
    
    dots_start_x = center_x - total_dots_width // 2
    dot_y = NAV_Y + (HEIGHT - NAV_Y) // 2
    
    for i in range(TOTAL_PAGES):
        dot_x = dots_start_x + i * dot_spacing
        if i == page_num:
            draw.ellipse([dot_x - 5, dot_y - 5, dot_x + 5, dot_y + 5], fill=CYBER_ORANGE)
        else:
            draw.ellipse([dot_x - 3, dot_y - 3, dot_x + 3, dot_y + 3], fill=(200, 200, 200))

def draw_cyber_box(draw, x, y, w, h, color=CYBER_ORANGE):
    """Draw cyberpunk style box with thick borders and corner circuits"""
    glow = (color[0]//4, color[1]//4, color[2]//4)
    draw.rectangle([x-1, y-1, x+w+1, y+h+1], outline=glow, width=1)
    draw.rectangle([x, y, x+w, y+h], outline=color, width=3)
    
    corner_len = 15
    # Top-left
    draw.line([x, y+corner_len, x, y], fill=color, width=3)
    draw.line([x, y, x+corner_len, y], fill=color, width=3)
    draw.line([x+corner_len, y, x+corner_len, y+8], fill=color, width=2)
    draw.ellipse([x+corner_len-2, y+8, x+corner_len+2, y+12], fill=color)
    # Top-right
    draw.line([x+w-corner_len, y, x+w, y], fill=color, width=3)
    draw.line([x+w, y, x+w, y+corner_len], fill=color, width=3)
    draw.line([x+w-corner_len, y, x+w-corner_len, y+8], fill=color, width=2)
    draw.ellipse([x+w-corner_len-2, y+8, x+w-corner_len+2, y+12], fill=color)
    # Bottom-left
    draw.line([x, y+h-corner_len, x, y+h], fill=color, width=3)
    draw.line([x, y+h, x+corner_len, y+h], fill=color, width=3)
    draw.line([x+corner_len, y+h, x+corner_len, y+h-8], fill=color, width=2)
    draw.ellipse([x+corner_len-2, y+h-12, x+corner_len+2, y+h-8], fill=color)
    # Bottom-right
    draw.line([x+w-corner_len, y+h, x+w, y+h], fill=color, width=3)
    draw.line([x+w, y+h-corner_len, x+w, y+h], fill=color, width=3)
    draw.line([x+w-corner_len, y+h, x+w-corner_len, y+h-8], fill=color, width=2)
    draw.ellipse([x+w-corner_len-2, y+h-12, x+w-corner_len+2, y+h-8], fill=color)

def get_gradient_color(percent):
    if percent < 30:
        return (0, 255, 100)
    elif percent < 50:
        t = (percent - 30) / 20
        return (int(255 * t), 255, int(100 * (1 - t)))
    elif percent < 70:
        t = (percent - 50) / 20
        return (255, int(255 - 55 * t), 0)
    elif percent < 85:
        t = (percent - 70) / 15
        return (255, int(200 - 150 * t), 0)
    else:
        return (255, 50, 30)

def draw_segmented_bar(draw, x, y, w, h, percent, color=None, segments=10):
    gap = 3
    segment_w = (w - (segments - 1) * gap) // segments
    filled = int(segments * percent / 100)
    
    for i in range(segments):
        sx = x + i * (segment_w + gap)
        if i < filled:
            seg_percent = (i + 1) * 100 / segments
            seg_color = get_gradient_color(seg_percent)
            draw.rectangle([sx, y, sx + segment_w, y + h], fill=seg_color)
            highlight = (min(seg_color[0]+40, 255), min(seg_color[1]+40, 255), min(seg_color[2]+40, 255))
            draw.line([sx+1, y+1, sx + segment_w-1, y+1], fill=highlight, width=1)
        else:
            draw.rectangle([sx, y, sx + segment_w, y + h], fill=(20, 20, 30), outline=(50, 50, 60))

def draw_progress_bar(draw, x, y, w, h, percent, color, bg_color=(40, 42, 55)):
    draw.rounded_rectangle([x, y, x + w, y + h], radius=3, fill=bg_color)
    fill_w = int((w - 2) * min(percent, 100) / 100)
    if fill_w > 0:
        draw.rounded_rectangle([x + 1, y + 1, x + 1 + fill_w, y + h - 1], radius=2, fill=color)

# ============== PI SYSTEM FUNCTIONS ==============
def get_cpu_usage():
    try:
        with open('/proc/stat', 'r') as f:
            line = f.readline()
        parts = line.split()
        idle = int(parts[4])
        total = sum(int(p) for p in parts[1:])
        if not hasattr(get_cpu_usage, 'last'):
            get_cpu_usage.last = (idle, total)
            return 0
        last_idle, last_total = get_cpu_usage.last
        get_cpu_usage.last = (idle, total)
        idle_delta = idle - last_idle
        total_delta = total - last_total
        return int(100 * (1 - idle_delta / total_delta)) if total_delta else 0
    except:
        return 0

def get_memory_usage():
    try:
        with open('/proc/meminfo', 'r') as f:
            lines = f.readlines()
        mem = {{}}
        for line in lines[:5]:
            parts = line.split()
            mem[parts[0].rstrip(':')] = int(parts[1])
        total = mem.get('MemTotal', 1)
        available = mem.get('MemAvailable', 0)
        used = total - available
        percent = int(100 * used / total)
        return percent, used // 1024, total // 1024
    except:
        return 0, 0, 0

def get_cpu_temp():
    try:
        with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
            return int(f.read().strip()) / 1000
    except:
        return 0

def get_uptime():
    try:
        with open('/proc/uptime', 'r') as f:
            seconds = float(f.read().split()[0])
        days = int(seconds // 86400)
        hours = int((seconds % 86400) // 3600)
        mins = int((seconds % 3600) // 60)
        if days > 0:
            return f"{{days}}d {{hours}}h"
        elif hours > 0:
            return f"{{hours}}h {{mins}}m"
        else:
            return f"{{mins}}m"
    except:
        return "?"

def get_ip_address():
    try:
        result = subprocess.run(['hostname', '-I'], capture_output=True, text=True, timeout=2)
        ips = result.stdout.strip().split()
        return ips[0] if ips else "No IP"
    except:
        return "?"

def get_disk_usage():
    try:
        st = os.statvfs('/')
        total = st.f_blocks * st.f_frsize
        free = st.f_bavail * st.f_frsize
        used = total - free
        percent = int(100 * used / total)
        return percent, used // (1024**3), total // (1024**3)
    except:
        return 0, 0, 0

# ============== DASHBOARD 1: PI SYSTEM ==============
def render_system_dashboard():
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    
    cpu = get_cpu_usage()
    mem_pct, mem_used, mem_total = get_memory_usage()
    temp = get_cpu_temp()
    uptime = get_uptime()
    ip = get_ip_address()
    disk_pct, disk_used, disk_total = get_disk_usage()
    
    available_h = NAV_Y - 10
    box_w = (WIDTH - 30) // 2
    box_h = available_h - 10
    gap = 10
    start_x, start_y = 5, 5
    
    # Left box - stats
    bx, by = start_x, start_y
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "RASPBERRY PI", fill=CYBER_BRIGHT, font=font_medium)
    
    row_y = by + 35
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, cpu, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"CPU: {{cpu}}%", fill=CYBER_GOLD, font=font_small)
    
    row_y += 28
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, temp, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"TEMP: {{temp:.0f}}C", fill=CYBER_GOLD, font=font_small)
    
    row_y += 28
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, mem_pct, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"MEM: {{mem_pct}}%", fill=CYBER_GOLD, font=font_small)
    
    row_y += 28
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, disk_pct, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"DISK: {{disk_pct}}%", fill=CYBER_GOLD, font=font_small)
    
    # Right box - info
    bx = start_x + box_w + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "SYSTEM", fill=CYBER_BRIGHT, font=font_medium)
    
    row_y = by + 38
    draw.text((bx + 10, row_y), "IP:", fill=CYBER_DIM, font=font_small)
    draw.text((bx + 35, row_y), ip, fill=CYBER_CYAN, font=font_small)
    
    row_y += 28
    draw.text((bx + 10, row_y), "UP:", fill=CYBER_DIM, font=font_small)
    draw.text((bx + 35, row_y), uptime, fill=CYBER_BRIGHT, font=font_medium)
    
    row_y += 32
    draw.text((bx + 10, row_y), f"RAM: {{mem_used}}/{{mem_total}}MB", fill=CYBER_GOLD, font=font_small)
    
    row_y += 26
    draw.text((bx + 10, row_y), f"DISK: {{disk_used}}/{{disk_total}}GB", fill=CYBER_GOLD, font=font_small)
    
    draw_nav_bar(draw, 0)
    write_to_fb(img)

# ============== DASHBOARD 2: WINDOWS PC ==============
def get_windows_stats():
    try:
        resp = requests.get(f"http://{{WINDOWS_PC_IP}}:{{WINDOWS_PORT}}/system/stats", timeout=3)
        return resp.json()
    except:
        return None

def render_windows_dashboard():
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    
    stats = get_windows_stats()
    
    if not stats or 'error' in stats:
        draw_cyber_box(draw, 100, 80, 280, 120, CYBER_ORANGE)
        draw.text((180, 110), "WINDOWS", fill=CYBER_BRIGHT, font=font_big)
        draw.text((175, 145), "OFFLINE", fill=CYBER_RED, font=font_medium)
        draw_nav_bar(draw, 1)
        write_to_fb(img)
        return
    
    available_h = NAV_Y - 10
    box_w = (WIDTH - 30) // 2
    box_h = (available_h - 15) // 2
    gap = 10
    start_x, start_y = 5, 5
    
    # Box 1: CPU
    bx, by = start_x, start_y
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    
    cpu = stats.get('cpu_percent', 0)
    cpu_temp = stats.get('cpu_temp', 0)
    cpu_count = stats.get('cpu_count', 0)
    cpu_freq = stats.get('cpu_freq_current', stats.get('cpu_freq', 0))
    
    draw.text((bx + 10, by + 8), f"CPU ({{cpu_count}}c)", fill=CYBER_BRIGHT, font=font_medium)
    
    row_y = by + 32
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, cpu_temp, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"TEMP: {{cpu_temp:.0f}}C", fill=CYBER_GOLD, font=font_small)
    
    row_y += 26
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, cpu, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"LOAD: {{cpu:.0f}}%", fill=CYBER_GOLD, font=font_small)
    
    row_y += 26
    freq_pct = min(cpu_freq / 5000 * 100, 100)
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, freq_pct, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"FREQ: {{int(cpu_freq)}}", fill=CYBER_GOLD, font=font_small)
    
    # Box 2: GPU
    bx = start_x + box_w + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    
    gpu = stats.get('gpu_percent', 0)
    gpu_temp = stats.get('gpu_temp', 0)
    gpu_power = stats.get('gpu_power_w', 0)
    gpu_name = stats.get('gpu_name', 'GPU').replace('NVIDIA ', '').replace('GeForce ', '')
    
    draw.text((bx + 10, by + 8), f"GPU: {{gpu_name[:10]}}", fill=CYBER_BRIGHT, font=font_medium)
    
    row_y = by + 32
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, gpu_temp, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"TEMP: {{gpu_temp}}C", fill=CYBER_GOLD, font=font_small)
    
    row_y += 26
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, gpu, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"LOAD: {{gpu}}%", fill=CYBER_GOLD, font=font_small)
    
    row_y += 26
    pwr_pct = min(gpu_power / 320 * 100, 100)
    draw_segmented_bar(draw, bx + 10, row_y, 95, 16, pwr_pct, CYBER_ORANGE, 8)
    draw.text((bx + 115, row_y), f"PWR: {{gpu_power:.0f}}W", fill=CYBER_GOLD, font=font_small)
    
    # Box 3: RAM/Disk
    bx, by = start_x, start_y + box_h + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    
    ram = stats.get('ram_percent', 0)
    ram_used = stats.get('ram_used_gb', 0)
    ram_total = stats.get('ram_total_gb', 0)
    disk = stats.get('disk_percent', 0)
    disk_free = stats.get('disk_free_gb', 0)
    
    draw.text((bx + 10, by + 8), f"RAM: {{ram_used:.0f}}/{{ram_total:.0f}}GB", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 30), f"USED: {{ram:.0f}}%", fill=CYBER_GOLD, font=font_small)
    draw_segmented_bar(draw, bx + 10, by + 52, box_w - 25, 18, ram, CYBER_ORANGE, 12)
    draw.text((bx + 10, by + 80), f"DISK: {{disk:.0f}}%  |  {{disk_free:.0f}}GB FREE", fill=CYBER_GOLD, font=font_small)
    
    # Box 4: System
    bx = start_x + box_w + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    
    gpu_fan = stats.get('gpu_fan_percent', 0)
    uptime_h = stats.get('uptime_hours', 0)
    net_recv = stats.get('net_recv_gb', 0)
    
    if uptime_h >= 24:
        uptime_str = f"{{int(uptime_h // 24)}}D {{int(uptime_h % 24):02d}}H"
    else:
        uptime_str = f"{{uptime_h:.1f}}H"
    
    draw.text((bx + 10, by + 8), "SYS", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 32), "FAN:", fill=CYBER_DIM, font=font_small)
    draw.text((bx + 55, by + 32), f"{{gpu_fan}}%", fill=CYBER_GOLD, font=font_small)
    draw.text((bx + 10, by + 56), "NET:", fill=CYBER_DIM, font=font_small)
    draw.text((bx + 55, by + 56), f"{{net_recv:.1f}}GB", fill=CYBER_GOLD, font=font_small)
    draw.text((bx + 10, by + 80), "UP:", fill=CYBER_DIM, font=font_small)
    draw.text((bx + 55, by + 80), uptime_str, fill=CYBER_BRIGHT, font=font_medium)
    
    draw_nav_bar(draw, 1)
    write_to_fb(img)

# ============== DASHBOARD 3: PI-HOLE ==============
def pihole_auth():
    global pihole_sid, pihole_sid_time
    if pihole_sid and time.time() - pihole_sid_time < 1500:
        return pihole_sid
    try:
        resp = requests.post(f"{{PIHOLE_URL}}/api/auth", json={{"password": PIHOLE_PASSWORD}}, timeout=3)
        data = resp.json()
        if data.get("session", {{}}).get("valid"):
            pihole_sid = data["session"]["sid"]
            pihole_sid_time = time.time()
            return pihole_sid
    except:
        pass
    return None

def get_pihole_stats():
    sid = pihole_auth()
    if not sid:
        return None
    try:
        resp = requests.get(f"{{PIHOLE_URL}}/api/stats/summary", headers={{"sid": sid}}, timeout=3)
        data = resp.json()
        return data if "queries" in data else None
    except:
        return None

def render_pihole_dashboard():
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    
    stats = get_pihole_stats()
    if not stats:
        draw_cyber_box(draw, 100, 80, 280, 120, CYBER_ORANGE)
        draw.text((170, 110), "PI-HOLE", fill=CYBER_BRIGHT, font=font_big)
        draw.text((160, 145), "CONNECTING...", fill=CYBER_GOLD, font=font_small)
        draw_nav_bar(draw, 2)
        write_to_fb(img)
        return
    
    queries = stats.get("queries", {{}})
    total = queries.get("total", 0)
    blocked = queries.get("blocked", 0)
    pct = queries.get("percent_blocked", 0)
    cached = queries.get("cached", 0)
    forwarded = queries.get("forwarded", 0)
    clients = stats.get("clients", {{}}).get("active", 0)
    domains = stats.get("gravity", {{}}).get("domains_being_blocked", 0)
    
    available_h = NAV_Y - 10
    box_w = (WIDTH - 30) // 2
    box_h = (available_h - 15) // 2
    gap = 10
    start_x, start_y = 5, 5
    
    # Box 1: Queries
    bx, by = start_x, start_y
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "QUERIES", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 32), f"{{total:,}}", fill=CYBER_CYAN, font=font_big)
    draw.text((bx + 10, by + 65), f"{{clients}} CLIENTS", fill=CYBER_GOLD, font=font_small)
    
    # Box 2: Blocked
    bx = start_x + box_w + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "BLOCKED", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 32), f"{{blocked:,}}", fill=CYBER_RED, font=font_big)
    draw_segmented_bar(draw, bx + 10, by + 65, 120, 14, pct, CYBER_ORANGE, 10)
    draw.text((bx + 140, by + 65), f"{{pct:.1f}}%", fill=CYBER_GOLD, font=font_small)
    
    # Box 3: Traffic
    bx, by = start_x, start_y + box_h + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "TRAFFIC", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 35), "CACHED:", fill=CYBER_GOLD, font=font_small)
    draw.text((bx + 80, by + 35), f"{{cached:,}}", fill=CYBER_PURPLE, font=font_small)
    draw.text((bx + 10, by + 59), "FWD:", fill=CYBER_GOLD, font=font_small)
    draw.text((bx + 80, by + 59), f"{{forwarded:,}}", fill=CYBER_CYAN, font=font_small)
    
    # Box 4: Blocklist
    bx = start_x + box_w + gap
    draw_cyber_box(draw, bx, by, box_w, box_h, CYBER_ORANGE)
    draw.text((bx + 10, by + 8), "BLOCKLIST", fill=CYBER_BRIGHT, font=font_medium)
    draw.text((bx + 10, by + 35), f"{{domains:,}}", fill=CYBER_GREEN, font=font_medium)
    draw.text((bx + 10, by + 58), "DOMAINS", fill=CYBER_GOLD, font=font_small)
    
    draw_nav_bar(draw, 2)
    write_to_fb(img)

# ============== DASHBOARD 4: DOCKER ==============
def get_docker_data():
    try:
        resp = requests.get(f"http://{{WINDOWS_PC_IP}}:{{WINDOWS_PORT}}/docker/containers", timeout=5)
        data = resp.json()
        return data.get('containers', []), data.get('count', 0)
    except:
        return [], 0

def render_docker_dashboard():
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    
    containers, count = get_docker_data()
    
    if not containers:
        draw_cyber_box(draw, 100, 80, 280, 120, CYBER_ORANGE)
        draw.text((180, 110), "DOCKER", fill=CYBER_BRIGHT, font=font_big)
        draw.text((155, 145), "NO CONTAINERS", fill=CYBER_GOLD, font=font_medium)
        draw_nav_bar(draw, 3)
        write_to_fb(img)
        return
    
    cols, rows = 3, 4
    margin = 5
    start_y = 5
    card_w = (WIDTH - margin * (cols + 1)) // cols
    card_h = (NAV_Y - start_y - margin * (rows + 1)) // rows
    
    for i, c in enumerate(containers[:12]):
        row, col = i // cols, i % cols
        x = margin + col * (card_w + margin)
        y = start_y + row * (card_h + margin)
        
        status = c.get('status', '')
        is_healthy = 'healthy' in status.lower()
        is_up = 'up' in status.lower()
        
        if is_healthy:
            status_color = CYBER_GREEN
        elif is_up:
            status_color = CYBER_CYAN
        else:
            status_color = CYBER_RED
        
        draw.rectangle([x, y, x+card_w, y+card_h], fill=(15, 15, 25), outline=CYBER_ORANGE, width=2)
        draw.rectangle([x+2, y+2, x+5, y+card_h-2], fill=status_color)
        
        name = c.get('name', '?')
        for p in ['compassionate_', 'nervous_', 'elated_', 'determined_', 'naughty_', 'flamboyant_', 'upbeat_', 'suspicious_']:
            if name.startswith(p):
                name = name[len(p):]
                break
        name = name[:11] + '..' if len(name) > 13 else name
        draw.text((x+10, y+4), name, fill=CYBER_BRIGHT, font=font_small)
        
        image = c.get('image', '').split('/')[-1].split(':')[0]
        image = image[:13] + '..' if len(image) > 15 else image
        draw.text((x+10, y+20), image, fill=(100, 80, 30), font=font_tiny)
        
        if 'Up' in status:
            parts = status.replace('(healthy)', '').strip().split()
            up = f"{{parts[1]}}{{parts[2][0]}}" if len(parts) >= 3 else "Up"
            draw.text((x+card_w-32, y+card_h-14), up, fill=status_color, font=font_tiny)
    
    draw_nav_bar(draw, 3)
    write_to_fb(img)

# ============== PAGE SELECTOR GRID ==============
page_selector_active = False
PAGE_NAMES = ["PI", "WIN", "PIHOLE", "DOCKER", "MEDIA", "APPS"]

def render_page_selector():
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    
    draw.text((WIDTH//2 - 60, 8), "SELECT PAGE", fill=CYBER_BRIGHT, font=font_medium)
    
    cols, rows = 3, 2
    margin = 15
    start_y = 40
    card_w = (WIDTH - margin * (cols + 1)) // cols
    card_h = (NAV_Y - start_y - margin * (rows + 1)) // rows
    
    for i in range(min(TOTAL_PAGES, 6)):
        row, col = i // cols, i % cols
        x = margin + col * (card_w + margin)
        y = start_y + row * (card_h + margin)
        
        if i == current_page:
            draw_cyber_box(draw, x, y, card_w, card_h, CYBER_CYAN)
            text_color = CYBER_CYAN
        else:
            draw_cyber_box(draw, x, y, card_w, card_h, CYBER_ORANGE)
            text_color = CYBER_BRIGHT
        
        name = PAGE_NAMES[i] if i < len(PAGE_NAMES) else f"PAGE {{i+1}}"
        bbox = draw.textbbox((0, 0), name, font=font_medium)
        tw = bbox[2] - bbox[0]
        draw.text((x + (card_w - tw) // 2, y + card_h // 2 - 10), name, fill=text_color, font=font_medium)
        draw.text((x + 10, y + 8), f"{{i+1}}", fill=CYBER_ORANGE, font=font_small)
    
    draw.text((WIDTH//2 - 70, NAV_Y + 8), "TAP OUTSIDE TO CANCEL", fill=(100, 80, 40), font=font_tiny)
    write_to_fb(img)

def get_page_from_grid(sx, sy):
    cols, rows = 3, 2
    margin = 15
    start_y = 40
    card_w = (WIDTH - margin * (cols + 1)) // cols
    card_h = (NAV_Y - start_y - margin * (rows + 1)) // rows
    
    for i in range(min(TOTAL_PAGES, 6)):
        row, col = i // cols, i % cols
        x = margin + col * (card_w + margin)
        y = start_y + row * (card_h + margin)
        if x <= sx <= x + card_w and y <= sy <= y + card_h:
            return i
    return -1

# ============== BUTTON PAGE FUNCTIONS ==============
def get_btn_rect(idx):
    row, col = idx // COLS, idx % COLS
    x = MARGIN + col * (BTN_W + MARGIN)
    y = MARGIN + row * (BTN_H + MARGIN)
    return (x, y, x + BTN_W, y + BTN_H)

def is_animated_ext(path):
    if not path:
        return False
    lower = path.lower()
    return lower.endswith('.gif') or lower.endswith('.webp')

def load_gif_frames(path, size, use_cover=False):
    if not path or not is_animated_ext(path):
        return None
    pi_path = os.path.join(ICONS_DIR, os.path.basename(path.replace('\\\\', '/')))
    try:
        img = Image.open(pi_path)
        frames = []
        for frame_num in range(getattr(img, 'n_frames', 1)):
            img.seek(frame_num)
            frame = img.convert("RGBA")
            if use_cover:
                frame = cover_resize(frame, size[0], size[1])
            else:
                frame = frame.resize(size, Image.LANCZOS)
            frames.append(frame)
        return frames if frames else None
    except:
        return None

def cover_resize(img, target_w, target_h):
    img_w, img_h = img.size
    img_ratio = img_w / img_h
    target_ratio = target_w / target_h
    if img_ratio > target_ratio:
        new_h = target_h
        new_w = int(new_h * img_ratio)
    else:
        new_w = target_w
        new_h = int(new_w / img_ratio)
    img = img.resize((new_w, new_h), Image.LANCZOS)
    left = (new_w - target_w) // 2
    top = (new_h - target_h) // 2
    return img.crop((left, top, left + target_w, top + target_h))

def load_image(path, size, frame_idx=0, use_cover=False):
    if not path:
        return None
    pi_path = os.path.join(ICONS_DIR, os.path.basename(path.replace('\\\\', '/')))
    
    if is_animated_ext(path):
        cache_key = (pi_path, size, use_cover)
        if cache_key not in gif_cache:
            frames = load_gif_frames(path, size, use_cover)
            if frames:
                gif_cache[cache_key] = frames
        if cache_key in gif_cache:
            frames = gif_cache[cache_key]
            return frames[frame_idx % len(frames)]
    
    try:
        img = Image.open(pi_path).convert("RGBA")
        return cover_resize(img, size[0], size[1]) if use_cover else img.resize(size, Image.LANCZOS)
    except:
        return None

def make_button_frame_bytes(page_idx, highlight=-1):
    img = Image.new("RGB", (WIDTH, HEIGHT), BG_COLOR)
    draw = ImageDraw.Draw(img)
    buttons = BUTTON_PAGES[page_idx]["buttons"]
    
    for i, btn in enumerate(buttons):
        x1, y1, x2, y2 = get_btn_rect(i)
        color = tuple(btn.get("color", [60, 60, 80]))
        if i == highlight:
            color = (255, 255, 255)
        
        draw.rounded_rectangle([x1, y1, x2, y2], radius=12, fill=color, outline=CYBER_ORANGE, width=2)
        
        if i != highlight:
            bg_frame = gif_frame_indices.get(f"bg_{{page_idx}}_{{i}}", 0)
            bg_img = load_image(btn.get("background"), (BTN_W - 4, BTN_H - 4), bg_frame, use_cover=True)
            if bg_img:
                img.paste(bg_img, (x1 + 2, y1 + 2), bg_img)
            
            icon_frame = gif_frame_indices.get(f"icon_{{page_idx}}_{{i}}", 0)
            icon = load_image(btn.get("icon"), (50, 50), icon_frame)
            if icon:
                img.paste(icon, (x1 + (BTN_W - 50) // 2, y1 + 10), icon)
        
        label = btn.get("label", "")
        if label:
            bbox = draw.textbbox((0, 0), label, font=font_btn)
            tw = bbox[2] - bbox[0]
            draw.text((x1 + (BTN_W - tw) // 2, y2 - 25), label, fill=CYBER_BRIGHT, font=font_btn)
    
    draw_nav_bar(draw, NUM_DASHBOARD_PAGES + page_idx)
    
    arr = np.array(img, dtype=np.uint16)
    rgb565 = ((arr[:,:,0] >> 3) << 11) | ((arr[:,:,1] >> 2) << 5) | (arr[:,:,2] >> 3)
    return rgb565.astype(np.uint16).tobytes()

def has_animated():
    for page in BUTTON_PAGES:
        for btn in page["buttons"]:
            if is_animated_ext(btn.get("background", "")) or is_animated_ext(btn.get("icon", "")):
                return True
    return False

HAS_GIFS = has_animated()

gif_buttons_per_page = {{}}
for p_idx, page in enumerate(BUTTON_PAGES):
    gif_buttons_per_page[p_idx] = []
    for b_idx, btn in enumerate(page["buttons"]):
        if is_animated_ext(btn.get("background", "")) or is_animated_ext(btn.get("icon", "")):
            gif_buttons_per_page[p_idx].append(b_idx)
            gif_frame_indices[f"btn_{{p_idx}}_{{b_idx}}"] = 0

print("Pre-rendering button pages...")
frame_cache = {{}}
for p in range(len(BUTTON_PAGES)):
    frame_cache[(p, -1)] = make_button_frame_bytes(p, -1)
    for i in range(len(BUTTON_PAGES[p]["buttons"])):
        frame_cache[(p, i)] = make_button_frame_bytes(p, i)
print(f"Cached {{len(frame_cache)}} button frames!")

print("Pre-rendering GIF frames...")
gif_frame_cache = {{}}
for p_idx, page in enumerate(BUTTON_PAGES):
    for b_idx in gif_buttons_per_page.get(p_idx, []):
        btn = page["buttons"][b_idx]
        bg_frames = load_gif_frames(btn.get("background"), (BTN_W - 4, BTN_H - 4), use_cover=True)
        icon_frames = load_gif_frames(btn.get("icon"), (50, 50))
        
        num_frames = max(len(bg_frames) if bg_frames else 1, len(icon_frames) if icon_frames else 1)
        
        for f_idx in range(num_frames):
            btn_img = Image.new("RGB", (BTN_W, BTN_H), tuple(btn.get("color", [60, 60, 80])))
            draw = ImageDraw.Draw(btn_img)
            draw.rounded_rectangle([0, 0, BTN_W-1, BTN_H-1], radius=12, outline=CYBER_ORANGE, width=2)
            
            if bg_frames:
                btn_img.paste(bg_frames[f_idx % len(bg_frames)], (2, 2), bg_frames[f_idx % len(bg_frames)])
            if icon_frames:
                btn_img.paste(icon_frames[f_idx % len(icon_frames)], ((BTN_W - 50) // 2, 10), icon_frames[f_idx % len(icon_frames)])
            
            label = btn.get("label", "")
            if label:
                bbox = draw.textbbox((0, 0), label, font=font_btn)
                draw.text(((BTN_W - bbox[2] + bbox[0]) // 2, BTN_H - 25), label, fill=CYBER_BRIGHT, font=font_btn)
            
            arr = np.array(btn_img, dtype=np.uint16)
            rgb565 = ((arr[:,:,0] >> 3) << 11) | ((arr[:,:,1] >> 2) << 5) | (arr[:,:,2] >> 3)
            gif_frame_cache[(p_idx, b_idx, f_idx)] = rgb565.astype(np.uint16).tobytes()
        
        gif_frame_indices[f"btn_{{p_idx}}_{{b_idx}}_max"] = num_frames

print(f"Pre-rendered {{len(gif_frame_cache)}} GIF frames!")

def show_button_page(page_idx, highlight=-1):
    fb_mmap.seek(0)
    fb_mmap.write(frame_cache[(page_idx, highlight)])

def render_button_to_fb(page_idx, btn_idx):
    x1, y1, x2, y2 = get_btn_rect(btn_idx)
    frame_idx = gif_frame_indices.get(f"btn_{{page_idx}}_{{btn_idx}}", 0)
    max_frames = gif_frame_indices.get(f"btn_{{page_idx}}_{{btn_idx}}_max", 1)
    btn_bytes = gif_frame_cache.get((page_idx, btn_idx, frame_idx % max_frames))
    if not btn_bytes:
        return
    for row in range(BTN_H):
        offset = ((y1 + row) * WIDTH + x1) * 2
        row_start = row * BTN_W * 2
        fb_mmap[offset:offset + BTN_W * 2] = btn_bytes[row_start:row_start + BTN_W * 2]

def update_gif_buttons(page_idx):
    for btn_idx in gif_buttons_per_page.get(page_idx, []):
        render_button_to_fb(page_idx, btn_idx)

def advance_gif_frames():
    for key in gif_frame_indices:
        if not key.endswith("_max"):
            gif_frame_indices[key] += 1

def send_action(action, app_path=None):
    if not action:
        return
    try:
        if action == "custom_app" and app_path:
            from urllib.parse import quote
            requests.get(f"http://{{WINDOWS_PC_IP}}:{{WINDOWS_PORT}}/launch?path={{quote(app_path, safe='')}}", timeout=0.5)
        else:
            requests.get(f"http://{{WINDOWS_PC_IP}}:{{WINDOWS_PORT}}/action/{{action}}", timeout=0.3)
    except:
        pass

# ============== MAIN LOOP ==============
def touch_to_screen(tx, ty):
    sx = int((tx - CAL_X_MIN) / (CAL_X_MAX - CAL_X_MIN) * WIDTH)
    sy = int((ty - CAL_Y_MIN) / (CAL_Y_MAX - CAL_Y_MIN) * HEIGHT)
    if INVERT_Y:
        sy = HEIGHT - sy
    return max(0, min(WIDTH-1, sx)), max(0, min(HEIGHT-1, sy))

def render_current_page():
    if current_page == 0:
        render_system_dashboard()
    elif current_page == 1:
        render_windows_dashboard()
    elif current_page == 2:
        render_pihole_dashboard()
    elif current_page == 3:
        render_docker_dashboard()
    else:
        show_button_page(current_page - NUM_DASHBOARD_PAGES)

print("Ready!")
render_current_page()
touch = InputDevice(TOUCH_DEV)

touch_x, touch_y = 0, 0
touching = False
pending_touch = False
page_selector_active = False
last_gif_update = time.time()
last_dashboard_update = time.time()
GIF_INTERVAL = 0.06
DASHBOARD_INTERVAL = 1.0

while True:
    if current_page < NUM_DASHBOARD_PAGES:
        timeout = 0.5
    elif HAS_GIFS:
        timeout = 0.03
    else:
        timeout = None
    
    r, w, x = select.select([touch.fd], [], [], timeout)
    
    if not page_selector_active:
        if current_page < NUM_DASHBOARD_PAGES and time.time() - last_dashboard_update > DASHBOARD_INTERVAL:
            render_current_page()
            last_dashboard_update = time.time()
        
        if current_page >= NUM_DASHBOARD_PAGES and HAS_GIFS and time.time() - last_gif_update > GIF_INTERVAL:
            advance_gif_frames()
            update_gif_buttons(current_page - NUM_DASHBOARD_PAGES)
            last_gif_update = time.time()
    
    if r:
        for event in touch.read():
            if event.type == ecodes.EV_ABS:
                if event.code == ecodes.ABS_X:
                    touch_x = event.value
                elif event.code == ecodes.ABS_Y:
                    touch_y = event.value
            elif event.type == ecodes.EV_KEY and event.code == ecodes.BTN_TOUCH:
                if event.value == 1:
                    pending_touch = True
                    touching = True
                else:
                    touching = False
            elif event.type == ecodes.EV_SYN and event.code == ecodes.SYN_REPORT:
                if pending_touch and touching:
                    pending_touch = False
                    sx, sy = touch_to_screen(touch_x, touch_y)
                    
                    if page_selector_active:
                        selected = get_page_from_grid(sx, sy)
                        if selected >= 0:
                            current_page = selected
                        page_selector_active = False
                        render_current_page()
                        continue
                    
                    if sx >= RIGHT_NAV[0] and sy >= NAV_Y:
                        if current_page < TOTAL_PAGES - 1:
                            current_page += 1
                            render_current_page()
                        continue
                    
                    if sx <= LEFT_NAV[2] and sy >= NAV_Y:
                        if current_page > 0:
                            current_page -= 1
                            render_current_page()
                        continue
                    
                    if LEFT_NAV[2] < sx < RIGHT_NAV[0] and sy >= NAV_Y:
                        page_selector_active = True
                        render_page_selector()
                        continue
                    
                    if current_page >= NUM_DASHBOARD_PAGES:
                        btn_page_idx = current_page - NUM_DASHBOARD_PAGES
                        for i, btn in enumerate(BUTTON_PAGES[btn_page_idx]["buttons"]):
                            x1, y1, x2, y2 = get_btn_rect(i)
                            if x1 <= sx <= x2 and y1 <= sy <= y2:
                                show_button_page(btn_page_idx, i)
                                send_action(btn.get("action"), btn.get("app_path"))
                                time.sleep(0.05)
                                show_button_page(btn_page_idx)
                                break
'''
    return script

def main():
    try:
        import paramiko
    except ImportError:
        print("ERROR: paramiko required. Run: pip install paramiko")
        sys.exit(1)

    if not os.path.exists(CONFIG_FILE):
        print(f"ERROR: Config file not found: {CONFIG_FILE}")
        sys.exit(1)

    with open(CONFIG_FILE, 'r') as f:
        config = json.load(f)

    print(f"Config loaded: {len(config.get('pages', []))} button pages + 4 dashboards")

    script = generate_pi_script(config)
    print(f"Generated script: {len(script)} bytes")

    print(f"Connecting to {PI_HOST}...")
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(PI_HOST, username=PI_USER, password=PI_PASS, timeout=10)
    print("Connected!")

    sftp = ssh.open_sftp()

    try:
        sftp.mkdir(PI_ICONS_DIR)
    except:
        pass

    if os.path.exists(LOCAL_ICONS_DIR):
        files = os.listdir(LOCAL_ICONS_DIR)
        print(f"Uploading {len(files)} icons...")
        for filename in files:
            local_path = os.path.join(LOCAL_ICONS_DIR, filename)
            if os.path.isfile(local_path):
                remote_path = f'{PI_ICONS_DIR}/{filename}'
                sftp.put(local_path, remote_path)
                print(f"  {filename}")

    print("Uploading script...")
    with sftp.file(PI_SCRIPT, 'w') as f:
        f.write(script)

    sftp.close()

    print("Stopping old script...")
    stdin, stdout, stderr = ssh.exec_command('pkill -9 -f streamdeck_fast.py')
    stdout.channel.recv_exit_status()

    import time
    time.sleep(2)

    print("Starting new script...")
    ssh.exec_command(f'python3 {PI_SCRIPT} > /dev/null 2>&1 &')
    time.sleep(1)

    ssh.close()
    print("Deployed successfully!")
    print("Dashboards: Pi System | Windows PC | Pi-hole | Docker")
    print("Button pages: " + ", ".join([p.get('name', f'Page {i+1}') for i, p in enumerate(config.get('pages', []))]))

if __name__ == "__main__":
    main()
